# 파이프라이닝

파이프라이닝 구조는 한번에 하나의 명령어만 처리하는 것이 아닌, 하나의 명령어를 처리할 때 다른 명령어도 같이 처리한다.
자원을 놀리지 않고 역할을 부여해 동시에 여러 개의 명령어를 처리하여 효율적이다. 

# 프로세스 vs 스레드

프로세스는 프로그램이 실행된 상태를, 스레드는 프로세스의 실행 단위를 의미한다. 프로세스가 다른 프로세스에게 접근할 땐 IPC 통신이 필요한 반면, 스레드는 다른 스레드와 스택 영역을 제외한 메모리 영역을 공유하기 때문에 별도의 통신이 필요하지 않다.
# 멀티스레드의 장단점

멀티스레드는 메모리 영역을 공유해 메모리 자원을 아낄 수 있고, 다른 통신 기법이 필요하지 않다는 장점이 있다. 하지만 메모리 영역을 공유하기 때문에 하나의 스레드의 문제가 다른 스레드로 퍼질 가능성이 있다. 또한 메모리 동기화 문제가 발생할 수 있어 설계가 어렵고 디버깅이 까다롭다.
# cache(캐시)

캐시는 자주 사용하는 데이터를 저장하고 있는 임시 메모리이다. CPU와 메인메모리나 디스크 간의 이동은 비용이 많이 들기 때문에, CPU의 바로 옆에 위치시켜 비용을 줄여 성능을 향상시킨다. 하지만 캐시에 필요한 데이터가 없을 경우 cache miss가 발생하기 때문에 캐시 적중률을 높이는 것이 중요하다. 이를 위해서 지역성의 원리를 사용한다.

## 지역성의 원리

### 공간 지역성

최근에 사용한 데이터에 인접한 데이터가 호출될 가능성이 높음

### 시간 지역성

최근에 사용한 데이터가 다시 호출될 가능성이 높음

# 컴퓨터의 구성요소

컴퓨터의 구성요소는 프로세서, 메모리, 입출력장치이다.

## 프로세서

메모리로부터 명령어를 받아와 기계어로 변환하고 연산을 수행한다.

## 메모리

명령어나 데이터가 적재되는 공간이다.

## 입출력장치

데이터 입출력을 위한 컴퓨터의 외부장치이다.
# CPU의 동작 과정

제어 유닛은 메모리로부터 명령어를 얻어 기계어로 변환한 후 ALU에게 전달한다. 레지스터는 명령어 주소, 코드, 데이터를 MBR에 임시로 저장한다. ALU는 제어 유닛으로부터 받은 정보를 바탕으로 연산을 수행하고, 그 결과를 다시 제어 유닛에게 전달한다.
# 고급 언어, 어셈블리어, 기계어

고급언어는 C, Java, Python과 같은 일반적인 프로그래밍 언어를 말한다. 컴파일러가 고급 언어를 어셈블리어로 변환하는데, 어셈블리어는 기계 사고 방식의 언어이다. 어셈블러가 어셈블리어를 기계어로 변환하는데, 기계어는 컴퓨터가 이해 가능한 비트의 집합이다.
# 32비트 CPU와 64 비트 CPU

CPU는 프로그램이 실행될 때 한 번에 처리 가능한 크기가 정해져 있다. 32bit CPU는 32bit씩, 64bit CPU는 64bit씩 처리할 수 있다. 한번에 처리하는 데이터가 많을수록 입출력이 줄어들고 연산이 빨라지므로 64bit CPU가 더 빠르다.
# Base 64(베이스 육십사)란

Base 64는 8비트 이진 데이터를 문자 코드에 영향을 받지 않는 공통 ASCII 영역의 문자들로만 구성된 일련의 문자열로 바꾸는 인코딩 방식이다.
인코딩 시 24bit의 버퍼를 생성하여 6bit씩 잘라 Base64 테이블의 ASCII 문자로 변환한다.
2bit의 오버페드가 발생하지만 64개의 안전한 문자만 사용하기 때문에 통신 과정에서의 바이너리 데이터의 손실을 막을 수 있다.
# GPU와 CPU의 차이

CPU는 중앙처리장치로, 컴퓨터의 두뇌 역할을 한다. GPU(그래픽처리장치)는 CPU와 비슷한 하드웨어 구성요소지만 더 전문화되어있다.
CPU는 GPU보다 코어 수가 적지만 성능은 더욱 강력해서 직렬 명령 처리에 적합하다. 반면 GPU는 CPU보다는 성능이 떨어지지만 수 천개의 코어를 갖고 있어 병렬 작업에 적합하다. 
이러한 특징 때문에 딥러닝, 고성능 컴퓨팅, 자율 주행 교통 수단에는 GPU가 더 유용하다.
# RISC와 CISC(내용 추가 예정)

RISC와 CISC는 CPU를 설계하는 방식으로, 명령어가 하드웨어적인 방식(호환성이 나쁨)을 RISC, 명령어가 소프트웨어적인 방식(호환성 좋음)을 CISC라고 한다.
RISC는 핵심적인 명령어를 기반으로 적은 종류의 명령어를 사용하고 길이가 고정적이어서 동작 속도가 빠르다.
반면 CISC는 복잡하고 많은 명령어를 사용하고 길이가 가변적이어서 동작 속도가 느리다.
# 프로그램 실행 순서

사용자가 OS에게 프로그램 실행을 요청하는 OS는 프로그램 정보를 하드디스크로부터 읽어 할당된 메인 메모리에 적재한다.
연산을 위해 메모리에서 CPU로 fetch되면 제어 유닛이 코드를 해석하고 ALU에서 연산을 해 레지스터에 연산된 값을 저장한다.
# 메인 메모리의 영역 (code, data, stack, heap)

메인 메모리의 영역은 code, data, stack, heap 영역으로 나뉜다.
1) code 영역 : 프로그램의 소스 코드 저장. CPU가 코드 영역의 명령어를 가져와 처리.
2) data 영역 : 전역변수, 정적 변수 저장. 프로그램 시작->할당, 프로그램 종료-> 소멸.
3) statck 영역 : 함수 실행에 필요한 지역 변수, 매개 변수 저장. 프로그램이 사용하는 임시 메모리 영역. 함수 호출->할당, 함수 종료->소멸.
4) heap 영역 : 동적할당을 위해 생성된 동적 변수 저장. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되는 영역. 런타임에 영역의 크기가 결정됨.
* stack 영역과 heap 영역은 사실 같은 공간을 공유하기 때문에 스택 오버플로우/힙 오버플로우가 일어나지 않도록 주의해야 함.
# Compile과 Interpret

compile과 interpret은 소스코드를 변환하고 실행시키는 방식이다.(C, Java)
compile : 소스코드가 런타임되기 전 기계어로 한번에 변환, 해석.(Python)
interpret : 소스코드가 런타임된 후 한 줄씩 변환, 해석.
# 자료형의 종류와 크기

char : 8bit
short : 16bit
int : 32bit
float : 32bit
long : 32bit
double : 64bit
# 시스템 소프트웨어와 응용소프트웨어의 차이

시스템 sw : 사용자들이 컴퓨터를 효율적으로 사용할 수 있도록 도와주는 sw(OS, 컴파일러)
응용 sw : 특정 목적을 달성하기 위한 프로그램. 보통 일반 사용자들이 사용하는 프로그램.
# 시스템 버스(내용 추가 예정)

하드웨어의 각 구성요소 간 데이터 통신을 위한 통로이다. 데이터버스, 주소버스, 제어버스로 나뉜다.
데이터버스(MBR에서 보냄)는 단방향 통로이지만 주소버스(MAR에서 보냄)와 제어버스는 단방향 통로이다.
# 명령어 처리 과정(내용 추가 예정)

인출 사이클, 해독 사이클, 실행 사이클로 나뉜다.
인출 사이클 : pc(프로그램 카운터)에 저장된 MAC 주소를 MAR로 전달, 해당 주소에서 명령어를 인출한다. 인출한 명령어는 MBR에 저장된 후 pc값이 1 증가한다.
              이후 IR에 전달한다.
실행 사이클 : 데이터를 인출하고 처리한 뒤 그 처리된 데이터를 저장하는 과정을 거쳐 완료된다.
# 고정소수점, 부동소수점

고정소수점은 10진수를 2진수로 변환시킨 후 그대로 사용하는 방법으로 부호부, 정수부, 소수부로 표현함.
부동소수점은 2진수로 변환 후 정규화의 과정을 거쳐 IEEE 부동 소수점 방식인 부호부, 가수부, 지수부로 표현함.
